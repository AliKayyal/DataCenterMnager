//// Created by Lian Gh on 03/12/2019.//#include "DataCenterManager.h"///--------------------- OSnode - Tree Node -------------------------------//////**************************************************************************void FillTheArraysOS(int* data, AVLTree<OSnode*,OSnode>& tree);int FillTheArraysOSRecursive(int* hours, AvlNode<OSnode*,OSnode>* node,int counter);//logical operators for the classbool operator<(const OSnode& first, const OSnode& second){    if(first.numOfServers== second.numOfServers){        return (first.dataCenterID>second.dataCenterID);    }    return (first.numOfServers< second.numOfServers);}bool operator>(const OSnode& first, const OSnode& second){    if(first.numOfServers== second.numOfServers){        return (first.dataCenterID<second.dataCenterID);    }    return (first.numOfServers> second.numOfServers);}//finding in the tree of OSnode according to the data center idbool operator==(const OSnode& first, const OSnode& second){    return (first.dataCenterID==second.dataCenterID);}///**************************************************************************///--------------------- Data Center Class -------------------------------//////**************************************************************************bool operator<(const DataCenter& first, const DataCenter& second){    return (first.dataCenterID< second.dataCenterID);}bool operator>(const DataCenter& first, const DataCenter& second){    return (first.dataCenterID> second.dataCenterID);}bool operator==(const DataCenter& first, const DataCenter& second) {    return (first.dataCenterID == second.dataCenterID);}///**************************************************************************void DataCenterManager::updateWindowsAdd(DataCenter* data_center){    //Updating linux tree    OSnode LinuxNode(data_center->GetdataCenterID(),data_center->linux_Counter);    Linux_Tree.removeByKey(LinuxNode);    OSnode* newLinux= new OSnode(data_center->GetdataCenterID(),data_center->linux_Counter-1);    Linux_Tree.insert(newLinux,*newLinux);//updating windows tree    OSnode WindowsNode(data_center->GetdataCenterID(),data_center->windows_Counter);    Windows_Tree.removeByKey(WindowsNode);    OSnode* newWindows= new OSnode(data_center->GetdataCenterID(),data_center->windows_Counter+1);    Windows_Tree.insert(newWindows,*newWindows);//update counters    data_center->windows_Counter++;    data_center->linux_Counter--;}void DataCenterManager::updateLinuxAdd(DataCenter* data_center){    //Updating linux tree    OSnode LinuxNode(data_center->GetdataCenterID(),data_center->linux_Counter);    Linux_Tree.removeByKey(LinuxNode);    OSnode* newLinux= new OSnode(data_center->GetdataCenterID(),data_center->linux_Counter+1);    Linux_Tree.insert(newLinux,*newLinux);//updating windows tree    OSnode WindowsNode(data_center->GetdataCenterID(),data_center->windows_Counter);    Windows_Tree.removeByKey(WindowsNode);    OSnode* newWindows= new OSnode(data_center->GetdataCenterID(),data_center->windows_Counter-1);    Windows_Tree.insert(newWindows,*newWindows);//update counters    data_center->windows_Counter--;    data_center->linux_Counter++;}StatusType DataCenterManager::AddDataCenter(int dataCenterID, int numOfServers){    if(dataCenterID<=0 || numOfServers<=0){        return INVALID_INPUT;    }    if(DataCentersTree.find(dataCenterID)!=NULL){        return FAILURE;    }    OSnode* linuxNode=new OSnode(dataCenterID,numOfServers);    OSnode* windowsNode =new OSnode(dataCenterID,0);    DataCenter* data_center=new DataCenter(dataCenterID,numOfServers);//becarfull    try {        DataCentersTree.insert(data_center,dataCenterID);    }    catch (std::bad_alloc& bad_new) {        DataCentersTree.removeByKey(dataCenterID);        throw bad_new;    }    try {        Linux_Tree.insert(linuxNode,*linuxNode);    }    catch (std::bad_alloc& bad_new) {        DataCentersTree.removeByKey(dataCenterID);        throw bad_new;    }    try {        Windows_Tree.insert(windowsNode,*windowsNode);    }    catch (std::bad_alloc& bad_new) {        DataCentersTree.removeByKey(dataCenterID);        Linux_Tree.removeByKey(*linuxNode);        throw bad_new;    }    return SUCCESS;}StatusType DataCenterManager::RemoveDataCenter( int dataCenterID){    if(dataCenterID<=0){        return INVALID_INPUT;    }    DataCenter IdToDelete(dataCenterID);    ///checking if the data center find in the manager    if(DataCentersTree.find(dataCenterID)==NULL){        return FAILURE;    }    AvlNode<DataCenter*,int>* curr_data=DataCentersTree.find(dataCenterID);    ///deleting the data center from the two OS trees     ///-deleting from linux tree    int numOFLinuxServ =curr_data->data->linux_Counter;    OSnode ToDeleteLinux(dataCenterID,numOFLinuxServ);    Linux_Tree.removeByKey(ToDeleteLinux);     ///-deleting from windows    int numOFWindowsServ =curr_data->data->windows_Counter;    OSnode ToDeleteWindows(dataCenterID,numOFWindowsServ);    Windows_Tree.removeByKey(ToDeleteWindows);    ///deleting the data center from the data centers tree    DataCentersTree.removeByKey(dataCenterID);    return SUCCESS;}StatusType DataCenterManager::RequestServer( int dataCenterID, int serverID, int os, int *assignedID){    DataCenter id_to_find(dataCenterID);    ///CHECKS    if(serverID<0 || os>1 || os<0 || dataCenterID<=0 ||assignedID== nullptr){        return INVALID_INPUT;    }    if(DataCentersTree.find(dataCenterID)==NULL){        return FAILURE;    }    AvlNode<DataCenter*,int>* data_center= DataCentersTree.find(dataCenterID);    /// one more check to the params    if(serverID>=data_center->data->GetnumOfServers()){        return INVALID_INPUT;    }    ///if the wanted server is free   if(data_center->data->ptr_array[serverID]!= nullptr){       if(data_center->data->serverOS_array[serverID]==LINUX){           ListNode<int,int> * node_to_delete =data_center->data->ptr_array[serverID];           data_center->data->Linux_List.DeleteByNode(node_to_delete);           if(os!=LINUX){           updateWindowsAdd(data_center->data );       }       if(data_center->data->serverOS_array[serverID]==WINDOWS){           ListNode<int,int> * node_to_delete =data_center->data->ptr_array[serverID];           data_center->data->Windows_List.DeleteByNode(node_to_delete);           if(os!=WINDOWS){           updateLinuxAdd(data_center->data);           }       }       }       ///updating the arrays       data_center->data->ptr_array[serverID]= nullptr;       data_center->data->serverOS_array[serverID]=os;       *assignedID=serverID;       return SUCCESS;   }   ///if the wanted server is not free   else{       if(os==LINUX){           ///first we check the given os list           if(data_center->data->Linux_List.listSize != 0){              ListNode<int,int>* NodeToDelete = data_center->data->Linux_List.head;              int targetServer =NodeToDelete->key;               data_center->data->Linux_List.DeleteByNode(NodeToDelete);               data_center->data->ptr_array[targetServer]= nullptr;               data_center->data->serverOS_array[targetServer]=os;               *assignedID=targetServer;               return SUCCESS;       }           /// if the wanted list is empty           if(data_center->data->Windows_List.listSize != 0){               ListNode<int,int>* NodeToDelete = data_center->data->Windows_List.head;               int targetServer =NodeToDelete->key;               data_center->data->Windows_List.DeleteByNode(NodeToDelete);               data_center->data->ptr_array[targetServer]= nullptr;               data_center->data->serverOS_array[targetServer]=os;               //update linux and windows trees               updateLinuxAdd(data_center->data);               *assignedID=targetServer;               return SUCCESS;           }           /// we reach here if the two lists are empty           return FAILURE;       }       }       if(os==WINDOWS){           ///first we check the given os list           if(data_center->data->Windows_List.listSize != 0){               ListNode<int,int>* NodeToDelete = data_center->data->Windows_List.head;               int targetServer =NodeToDelete->key;               data_center->data->Windows_List.DeleteByNode(NodeToDelete);               data_center->data->ptr_array[targetServer]= nullptr;               data_center->data->serverOS_array[targetServer]=os;               *assignedID=targetServer;               return SUCCESS;           }           /// if the wanted list is empty           if(data_center->data->Linux_List.listSize != 0){               ListNode<int,int>* NodeToDelete = data_center->data->Linux_List.head;               int targetServer =NodeToDelete->key;               data_center->data->Linux_List.DeleteByNode(NodeToDelete);               data_center->data->ptr_array[targetServer]= nullptr;               data_center->data->serverOS_array[targetServer]=os;               //update linux and windows trees               updateWindowsAdd(data_center->data);               *assignedID=targetServer;               return SUCCESS;           }           /// we reach here if the two lists are empty           return FAILURE;       }    return SUCCESS; // Will not reach here}StatusType DataCenterManager::FreeServer( int dataCenterID, int serverID){    ///CHECKS    if(serverID<0 || dataCenterID<=0){        return INVALID_INPUT;    }    if(DataCentersTree.find(dataCenterID)==NULL){        return FAILURE;    }    AvlNode<DataCenter*,int>* data_center= DataCentersTree.find(dataCenterID);    /// one more check to the params    if(serverID>=data_center->data->GetnumOfServers()) {        return INVALID_INPUT;    }    /// if the server is already freed    if(data_center->data->ptr_array[serverID]!= nullptr){        return FAILURE;    }    ///add the server to the relevant list    if(data_center->data->serverOS_array[serverID]==LINUX){        data_center->data->ptr_array[serverID]=data_center->data->Linux_List.AddToLast(serverID,serverID);    }    if(data_center->data->serverOS_array[serverID]==WINDOWS){        data_center->data->ptr_array[serverID]=data_center->data->Windows_List.AddToLast(serverID,serverID);    }    return SUCCESS;}StatusType DataCenterManager::GetDataCentersByOS( int os, int **dataCenters, int* numOfDataCenters){ ///CHECKS if(dataCenters== nullptr || os<0 || numOfDataCenters== nullptr || os>1 ){     return INVALID_INPUT; } ///if there is no data centers int data_centers_num=DataCentersTree.getSize(); if(data_centers_num==0){     return FAILURE; } ///Malloc for the returned array *numOfDataCenters=data_centers_num; *dataCenters=(int*) malloc (data_centers_num * sizeof(int));if(!*dataCenters){    return ALLOCATION_ERROR;} ///inorder wondering on LINUX tree if(os==LINUX){     FillTheArraysOS(*dataCenters,Linux_Tree); } ///inorder wondering on WINDOWS tree if(os==WINDOWS){     FillTheArraysOS(*dataCenters,Windows_Tree); }    return SUCCESS;}void FillTheArraysOS(int* data, AVLTree<OSnode*,OSnode>& tree){    FillTheArraysOSRecursive(data,tree.head,0);}int FillTheArraysOSRecursive(int* data, AvlNode<OSnode*,OSnode>* node,int counter) {    if(node == NULL)        return counter;    if(node->right != NULL)        counter = FillTheArraysOSRecursive(data, node->right, counter);    data[counter++] = node->data->GetDataCenterID();    if(node->left != NULL)        counter = FillTheArraysOSRecursive(data, node->left, counter);    return counter;}